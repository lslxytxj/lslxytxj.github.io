<!DOCTYPE html>
<html>
<head>
    <title>洛伦茨系统3D可视化</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #333; }
        canvas { width: 100%; height: 100%; display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">洛伦茨系统3D可视化<br>拖动鼠标旋转视角，滚轮缩放</div>
    <div class="controls">
        <div>
            a: <input type="range" id="a" min="0" max="30" step="0.1" value="10"> <span id="aValue">10</span>
        </div>
        <div>
            b: <input type="range" id="b" min="0" max="50" step="0.1" value="28"> <span id="bValue">28</span>
        </div>
        <div>
            c: <input type="range" id="c" min="0" max="10" step="0.1" value="8/3"> <span id="cValue">8/3</span>
        </div>
        <button id="reset">重置轨迹</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // 初始化场景、相机和渲染器
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 添加轨道控制器
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // 设置相机位置
        camera.position.set(0, 0, 50);
        controls.update();

        // 添加坐标轴辅助
        const axesHelper = new THREE.AxesHelper(20);
        scene.add(axesHelper);

        // 洛伦茨系统参数
        let a = 10;
        let b = 28;
        let c = 8/3;
        
        // 初始条件
        let x = 0.1;
        let y = 0;
        let z = 0;
        
        // 时间步长
        const dt = 0.01;
        
        // 存储轨迹点
        const points = [];
        const geometry = new THREE.BufferGeometry();
        const material = new THREE.LineBasicMaterial({ color: 0x00ffff });
        const line = new THREE.Line(geometry, material);
        scene.add(line);
        
        // 更新滑块显示
        document.getElementById('a').addEventListener('input', function() {
            a = parseFloat(this.value);
            document.getElementById('aValue').textContent = a;
        });
        
        document.getElementById('b').addEventListener('input', function() {
            b = parseFloat(this.value);
            document.getElementById('bValue').textContent = b;
        });
        
        document.getElementById('c').addEventListener('input', function() {
            c = parseFloat(this.value);
            document.getElementById('cValue').textContent = c;
        });
        
        document.getElementById('reset').addEventListener('click', function() {
            points.length = 0;
            x = 0.1;
            y = 0;
            z = 0;
        });

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 更新洛伦茨系统
            const dx = a * (y - x) * dt;
            const dy = (x * (b - z) - y) * dt;
            const dz = (x * y - c * z) * dt;
            
            x += dx;
            y += dy;
            z += dz;
            
            // 添加新点
            points.push(new THREE.Vector3(x, y, z));
            
            // 限制点的数量以避免性能问题
            if (points.length > 5000) {
                points.shift();
            }
            
            // 更新几何体
            geometry.setFromPoints(points);
            
            // 更新控制器
            controls.update();
            
            // 渲染场景
            renderer.render(scene, camera);
        }
        
        // 处理窗口大小变化
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
